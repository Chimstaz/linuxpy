#
# This file is part of the python-linux project
#
# Copyright (c) 2023 Tiago Coutinho
# Distributed under the GPLv3 license. See LICENSE for more info.

"""
Generate a Python extension module with the constants defined in linux/input.h.
"""

from __future__ import print_function

import collections
import datetime
import os
import re
import sys
import tempfile
import logging

MACRO_RE = re.compile(r"#define[ \t]+(?P<name>[\w]+)[ \t]+(?P<value>.+)\s*")

MACRO_MAP = {
    "V4L2_SEL_FLAG_": ("SelectionFlag", "IntFlag"),
    "V4L2_SEL_TGT_": ("SelectionTarget", "IntEnum"),
    "V4L2_SUBDEV_SEL_TGT_": ("SelectionTarget", "IntEnum"),
    "V4L2_CAP_": ("Capability", "IntEnum"),
    "V4L2_PIX_FMT_": ("PixelFormat", "IntEnum"),
    "V4L2_BUF_TYPE_": ("BufferType", "IntEnum"),
    "V4L2_BUF_FLAG_": ("BufferFlag", "IntFlag"),
    "V4L2_MEMORY_": ("Memory", "IntEnum"),
    "V4L2_FMT_FLAG_": ("ImageFormatFlag", "IntFlag"),
    "V4L2_FIELD_": ("Field", "IntEnum"),
    "V4L2_FRMSIZE_TYPE_": ("FrameSizeType", "IntEnum"),
    "V4L2_FRMIVAL_TYPE_": ("FrameIntervalType", "IntEnum"),
    "V4L2_IN_ST_": ("InputStatus", "IntFlag"),
    "V4L2_INPUT_TYPE_": ("InputType", "IntEnum"),
    "V4L2_IN_CAP_": ("InputCapabilities", "IntEnum"),
    "V4L2_CTRL_CLASS_": ("ControlClass", "IntEnum"),
    "V4L2_CTRL_TYPE_": ("ControlType", "IntEnum"),
    "V4L2_CID_": ("ControlID", "IntEnum"),
    "V4L2_CTRL_FLAG_": ("ControlFlag", "IntFlag"),
    "V4L2_PRIORITY_": ("Priority", "IntEnum"),
    "V4L2_TC_TYPE_": ("TimeCodeType", "IntEnum"),
    "V4L2_TC_FLAG_": ("TimeCodeFlag", "IntFlag"),
    "V4L2_EVENT_": ("EventType", "IntEnum"),
    "V4L2_EVENT_SUB_FL_": ("EventSubscriptionFlag", "IntFlag"),
    "VIDIOC_": ("IOC", "Enum")
}

TEMPLATE = """\
#
# This file is part of the python-linux project
#
# Copyright (c) 2023 Tiago Coutinho
# Distributed under the GPLv3 license. See LICENSE for more info.

# This file has been generated by linux.media.video.gencodes
# Date: {date}
# Version: {version}

import enum
import ctypes

from linux.ioctl import IOR as _IOR, IOW as _IOW, IOWR as _IOWR 
from linux.media.video.util import v4l2_fourcc
from linux.ctypes import u8, i8, u16, i16, u32, i32, u64, i64, cuint, cint, Struct, Union

{enums_body}


{structs_body}"""


def gen_reader(filename):
    with open(filename, "r") as f:
        for line in f:
            line = line.strip()
            expr = MACRO_RE.match(line)
            if expr:
                yield expr.groupdict()


def decode_value(value, context, name_map):
    value = value.replace("*/", "")
    value = value.replace("/*", "#")
    value = value.replace("struct " , "")
    try:
        return "0x{:X}".format(int(value))
    except ValueError:
        try:
            return "0x{:X}".format(int(value, 16))
        except ValueError:
            for c_name, py_name in name_map.items():
                py_class, name = py_name.split(".", 1)
                if py_class == context:
                    py_name = name
                value = value.replace(c_name, py_name)
            return value


def _find_macro_type(name):
    for key, value in MACRO_MAP.items():
        if key in name:
            return key, value


def fill_enums(filename, enums, name_map):
    for item in gen_reader(filename):
        c_name, c_value = item["name"], item["value"]
        group = _find_macro_type(c_name)
        if group:
            prefix, (class_name, class_type) = group
            py_value = decode_value(c_value, class_name, name_map)
            py_name = c_name[len(prefix):]
            enums[(class_name, class_type)].append((py_name, py_value))
            name_map[c_name] = f"{class_name}.{py_name}"
        else:
            logging.warning("ignored %s", c_name)


def enum_str(name, items, base="enum.Enum"):
    lines = [
        "    {} = {}".format(("_" if k[0].isdigit() else "") + k, v) 
        for k, v in items
    ]
    lines.insert(0, "class {name}(enum.{base}):".format(name=name, base=base))
    return "\n".join(lines)


def gen_enum_str(enums):
    for (name, base), items in enums.items():
        yield enum_str(name, items, base=base)


def enums_str(enums):
    return "\n\n\n".join(gen_enum_str(enums))


CTYPES_MAP = {
    "unsigned char": "u8",
    "signed char": "i8",
    "char": "i8",
    "short unsigned int": "u16",
    "short int": "i16",
    "unsigned int": "cuint",
    "int": "cint",
    "long unsigned int": "u64",
    "long long unsigned int": "i64",
    "long int": "i64",
    "long long int": "i64",
    "void": "None",
}


def find_xml_base_type(etree, type_id, context):
    while True:
        node = etree.find("*[@id='{}']".format(type_id))
        if node is None:
            logging.error("unknown field")
            return
        if node.tag == "Struct":
            return node.get("name"), node.get("id")
        elif node.tag == "FundamentalType":
            return CTYPES_MAP[node.get("name")], node.get("id")
        elif node.tag == "PointerType":
            name, base_id = find_xml_base_type(etree, node.get("type"), context)
            return "ctypes.POINTER({})".format(name), base_id
        elif node.tag == "Union":
            return build_struct(etree, node, context), node.get("id")
        type_id = node.get("type")


def build_field(etree, node, context):
    type_code = node.get("type")
    base_type = find_xml_base_type(etree, type_code, context)
    if base_type is None:
        return
    field_type, base_type_code = base_type

    return {
        "name": node.get("name"), 
        "type": field_type, 
        "type_code": base_type_code,
        "context": context,
    }


def build_struct(etree, node, context):
    name = node.get("name")
    members = node.get("members").split()
    fields = (etree.find(f"*[@id='{member}']") for member in members)
    fields = (field for field in fields if field.tag != "Union")
    fields = (build_field(etree, field, name) for field in fields)
    fields = [field for field in fields if field is not None]

    return {
        "name": name,
        "type": node.tag,
        "fields": fields,
    }


def gen_structs(header_filename, xml_filename):
    import xml.etree.ElementTree

    etree = xml.etree.ElementTree.parse(xml_filename)
    header_tag = etree.find("File[@name='{}']".format(header_filename))
    if header_tag is None:
        return
    header_id = header_tag.get("id")
    struct_nodes = etree.findall("Struct[@file='{}'][@context='_1']".format(header_id))
    for struct_node in struct_nodes:
        struct = build_struct(etree, struct_node, None)
        for field in struct["fields"]:
            type_code = field["type_code"]
            type_node = etree.find("*[@id='{}']".format(type_code))
            if type_node.tag == "Struct" and type_node.get("file") != header_id:
                yield build_struct(etree, type_node, struct["name"])
        yield struct


STRUCT_TEMPLATE = """\
class {name}({type}):
{unions}{anonymous}
    pass

{name}._fields_ = [
{fields}
    ]"""


def field_str(field):
    name = field["name"]
    field_type = field["type"]
    if isinstance(field_type, str):
        union = None
    else:
        assert not field_type["name"]
        anonymous = False
        if not name:
            name = "_m"
            anonymous = True
        field_type["name"] = name.upper()
        union_str = struct_str(field_type)
        union_str = "\n".join(["    {}".format(line) for line in union_str.split("\n")])
        field_type = field_type["name"]
        context = field["context"]
        if context:
            field_type = f"{context}.{field_type}"
        union = union_str, name, anonymous
    return (
        """        ('{name}', {type})""".format(name=name, type=field_type),
        union,
    )


def struct_str(struct):
    unions, fields = [], []
    for field in struct["fields"]:
        f_str, union = field_str(field)
        if union:
            unions.append(union)
        fields.append(f_str)
    ctype = "Struct" if struct["type"] == "Struct" else "Union"
    if any(union[2] for union in unions):
        anonymous = str(tuple(union[1] for union in unions if union[2]))
        anonymous = f"    _anonymous_ = {anonymous}"
    else:
        anonymous = ""        
    return STRUCT_TEMPLATE.format(
        name=struct["name"],
        type=ctype,
        fields=",\n".join(fields),
        anonymous=anonymous,
        unions="\n\n".join(union[0] for union in unions) + ("\n" if unions else ""),
    )


def structs_str(structs):
    return "\n\n\n".join((struct_str(struct) for struct in structs))


def main():
    # Default header file locations
    headers = [
        "/usr/include/linux/v4l2-common.h",
        "/usr/include/linux/v4l2-controls.h",
        "/usr/include/linux/videodev2.h",
        "/usr/include/linux/v4l2-mediabus.h",
        "/usr/include/linux/v4l2-dv-timings.h",
        "/usr/include/linux/v4l2-subdev.h",
    ]

    if sys.argv[1:]:
        headers = sys.argv[1:]

    logging.basicConfig()

    uname = list(os.uname())
    del uname[1]
    uname = " ".join(uname)

    temp_dir = tempfile.mkdtemp()
    enums = collections.defaultdict(list)
    hole = {}
    structs = []
    for header in headers:
        fill_enums(header, enums, hole)
        base_header = os.path.split(os.path.splitext(header)[0])[1]
        xml_filename = os.path.join(temp_dir, base_header + ".xml")
        cmd = "castxml --castxml-output=1.0.0 -o {} {}".format(xml_filename, header)
        assert os.system(cmd) == 0
        structs.extend(gen_structs(header, xml_filename))

    ioc = enums.pop(("IOC", "Enum"))
    enums_body = enums_str(enums)
    structs_body = structs_str(structs)
#    structs_body = ""

    print(
        TEMPLATE.format(
            version=uname,
            date=datetime.datetime.now(),
            enums_body=enums_body,
            structs_body=structs_body,
        )
    )


if __name__ == "__main__":
    main()
