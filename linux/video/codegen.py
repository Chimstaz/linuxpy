#
# This file is part of the python-linux project
#
# Copyright (c) 2023 Tiago Coutinho
# Distributed under the GPLv3 license. See LICENSE for more info.


import datetime
import logging
import os
import platform
import re
import tempfile
import textwrap

import black
import xml.etree.ElementTree

HEADERS = [
    "/usr/include/linux/v4l2-common.h",
    "/usr/include/linux/v4l2-controls.h",
    "/usr/include/linux/videodev2.h",
    "/usr/include/linux/v4l2-mediabus.h",
    "/usr/include/linux/v4l2-dv-timings.h",
    "/usr/include/linux/v4l2-subdev.h",
]

CTYPES_MAP = {
    "unsigned char": "u8",
    "signed char": "cchar",
    "char": "cchar",
    "short unsigned int": "u16",
    "short int": "i16",
    "unsigned int": "cuint",
    "int": "cint",
    "long unsigned int": "u64",
    "long long unsigned int": "i64",
    "long int": "i64",
    "long long int": "i64",
    "void": "None",
}

MACRO_RE = re.compile(r"#define[ \t]+(?P<name>[\w]+)[ \t]+(?P<value>.+)\s*")

TEMPLATE = """\
#
# This file is part of the python-linux project
#
# Copyright (c) 2023 Tiago Coutinho
# Distributed under the GPLv3 license. See LICENSE for more info.

# This file has been generated by {name} 
# Date: {date}
# System: {system}
# Release: {release}
# Version: {version}

import enum

from linux.ioctl import IO as _IO, IOR as _IOR, IOW as _IOW, IOWR as _IOWR 
from linux.ctypes import u8, i8, u16, i16, u32, i32, u64, i64, cuint, cint, cchar
from linux.ctypes import Struct, Union, POINTER, timeval, timespec
from linux.video.util import v4l2_fourcc, v4l2_fourcc_be

v4l2_std_id = u64

{enums_body}


{structs_body}


{iocs_body}"""


class CEnum:
    def __init__(self, name, prefix, klass=None):
        self.name = name
        self.prefix = prefix
        if klass is None:
            klass = "IntFlag" if "FLAG" in prefix else "IntEnum"
        self.klass = klass
        self.values = None

    def add_item(self, name, value):
        if self.empty:
            self.values = []
        self.values.append((name, value))

    @property
    def empty(self):
        return self.values is None

    def __repr__(self):
        if self.values:
            fields = "\n".join(f"    {name} = {value}" for name, value in self.values)
        else:
            fields = "    pass"
        return f"""\
class {self.name}(enum.{self.klass}):
{fields}
"""

# macros from #define statements
MACRO_ENUMS = [
    CEnum("SelectionFlag", "V4L2_SEL_FLAG_", "IntFlag"),
    CEnum("SelectionTarget", "V4L2_SEL_TGT_"),
    CEnum("Capability", "V4L2_CAP_", "IntFlag"),
    CEnum("PixelFormat", "V4L2_PIX_FMT_"),
    CEnum("BufferFlag", "V4L2_BUF_FLAG_", "IntFlag"),
    CEnum("ImageFormatFlag", "V4L2_FMT_FLAG_", "IntFlag"),
    CEnum("InputStatus", "V4L2_IN_ST_", "IntFlag"),
    CEnum("InputType", "V4L2_INPUT_TYPE_"),
    CEnum("InputCapabilities", "V4L2_IN_CAP_", "IntFlag"),
    CEnum("ControlClass", "V4L2_CTRL_CLASS_"),
    CEnum("ControlID", "V4L2_CID_"),
    CEnum("ControlFlag", "V4L2_CTRL_FLAG_", "IntFlag"),
    CEnum("TimeCodeType", "V4L2_TC_TYPE_"),
    CEnum("TimeCodeFlag", "V4L2_TC_FLAG_", "IntFlag"),
    CEnum("EventType", "V4L2_EVENT_"),
    CEnum("EventSubscriptionFlag", "V4L2_EVENT_SUB_FL_", "IntFlag"),
    CEnum("IOC", "VIDIOC_", "Enum"),
]

# special enums that require translations
ENUMS = {
    ""
}


def lines(filename):
    with open(filename) as source:
        for line in source:
            yield line.strip()


def macro_lines(filename):
    for line in lines(filename):
        if line.startswith("#define"):
            matches = MACRO_RE.match(line)
            if matches:
                data = matches.groupdict()
                yield data["name"], data["value"]


def decode_macro_value(value, context, name_map):
    value = value.replace("*/", "")
    value = value.replace("/*", "#")
    value = value.replace("struct " , "")
    for dtype in 'ui':
        for size in (8, 16, 32, 64):
            typ = f"{dtype}{size}"
            value = value.replace(f"__{typ}", typ)
    try:
        return "0x{:X}".format(int(value))
    except ValueError:
        try:
            return "0x{:X}".format(int(value, 16))
        except ValueError:
            for c_name, py_name in name_map.items():
                py_class, name = py_name.split(".", 1)
                if py_class == context.name:
                    py_name = name
                value = value.replace(c_name, py_name)
            return value


def find_macro_enum(name):
    for cenum in MACRO_ENUMS:
        if cenum.prefix in name:
            return cenum


def fill_macros(filename, name_map):
    for cname, cvalue in macro_lines(filename):
        if "PRIVATE" in cname:
            continue
        cenum = find_macro_enum(cname)
        if cenum is None:
            continue
        py_value = decode_macro_value(cvalue, cenum, name_map)
        py_name = cname[len(cenum.prefix):]
        if py_name[0].isdigit():
            py_name = f"_{py_name}"
        cenum.add_item(py_name, py_value)
        name_map[cname] = f"{cenum.name}.{py_name}"


class CStruct:

    def __init__(self, node, node_members, pack=False):
        self.node = node
        self.node_members = node_members
        self.pack = pack
        self.name = node.get("name")
        self.parent = None
        self.fields = []
        self.children = {}
        self.is_anonymous = not self.name
        self.anonymous_fields = []

    @property
    def type(self):
        return self.node.tag
    
    @property
    def id(self):
        return self.node.get("id")
    
    @property
    def member_ids(self):
        return self.node.get("members").split()

    @property
    def context_id(self):
        return self.node.get("context")

    def __repr__(self):
        fields = ", ".join(f'("{fname}", {ftype})' for fname, ftype in self.fields)

        text = f"class {self.name}({self.type}):\n"
        if self.pack:
            text += "    _pack_ = True\n"
        if self.children:
            children = "\n".join(str(child) for child in self.children.values())
            text += textwrap.indent(children, 4*" ")
            text += "\n"
        if self.anonymous_fields:
            text += f"    _anonymous_ = {tuple(self.anonymous_fields)}\n"
        if not self.children and not self.anonymous_fields:
            text += "    pass"
        text += f"\n{self.name}._fields_ = [{fields}]\n"
        return text


def find_xml_base_type(etree, context, type_id):
    while True:
        node = etree.find("*[@id='{}']".format(type_id))
        if node is None:
            return
        if node.tag == "Struct":
            return node.get("name"), node.get("id")
        elif node.tag == "FundamentalType":
            return CTYPES_MAP[node.get("name")], node.get("id")
        elif node.tag == "PointerType":
            name, base_id = find_xml_base_type(etree, context, node.get("type"))
            return f"POINTER({name})".format(name), base_id
        elif node.tag == "Union":
            return node.get("name"), node.get("id")
        elif node.tag == "ArrayType":
            name, base_id = find_xml_base_type(etree, context, node.get("type"))
            if name == "u8":
                name = "cchar"
            n = int(node.get("max")) + 1
            return f"{name} * {n}", base_id

        type_id = node.get("type")


def get_structs(header_filename, xml_filename):
    etree = xml.etree.ElementTree.parse(xml_filename)
    header_tag = etree.find("File[@name='{}']".format(header_filename))
    structs = {}
    if header_tag is None:
        return structs
    header_id = header_tag.get("id")
    nodes = etree.findall(f"Struct[@file='{header_id}']")
    nodes += etree.findall(f"Union[@file='{header_id}']")
    for node in nodes:
        member_ids = node.get("members").split()
        fields = (etree.find(f"*[@id='{member_id}']") for member_id in member_ids)
        fields = [
            field
            for field in fields
            if field.tag not in {"Union", "Struct", "Unimplemented"}
        ]
        pack = int(node.get("align")) == 8
        struct = CStruct(node, fields, pack)
        structs[struct.id] = struct
    for struct in structs.values():
        if struct.context_id != "_1":
            parent = structs.get(struct.context_id)
            if parent:
                parent.children[struct.id] = struct
                struct.parent = parent
            else:
                logging.error("Could not find parent")
        if not struct.name and struct.parent:
            struct.name = f"M{len(struct.parent.children)}"
    for struct in structs.values():
        for node in struct.node_members:
            name = node.get("name")
            base = find_xml_base_type(etree, struct, node.get("type"))
            if base is None:
                logging.warning("unknown field for %s", struct.name)
            else:
                base_type, base_id = base
                child = struct.children.get(base_id)
                if child is not None:
                    if not name:
                        name = child.name.lower()
                        struct.anonymous_fields.append(name)
                    if not base_type:
                        base_type = f"{struct.name}.{child.name}"
            struct.fields.append((name, base_type))

    return structs


def cname_to_pyname(name: str, capitalize=True, splitby="_",):
    if name.startswith("v4l2_"):
        name = name[5:]
    if capitalize:
        name = name.capitalize()
    return "".join(map(str.capitalize, name.split(splitby)))
    

def get_enums(header_filename, xml_filename):
    etree = xml.etree.ElementTree.parse(xml_filename)
    header_tag = etree.find("File[@name='{}']".format(header_filename))
    structs = {}
    if header_tag is None:
        return structs
    header_id = header_tag.get("id")
    nodes = etree.findall(f"Enumeration[@file='{header_id}']")
    for node in nodes:
        cname = node.get("name")
        py_name = cname_to_pyname(cname)
        prefix = cname.upper() + "_"
        raw_names = [child.get("name") for child in node]
        common_prefix = os.path.commonprefix(raw_names)
        values = []
        for child in node:
            name = child.get("name")
            name = name.removeprefix(prefix)
            name = name.removeprefix(common_prefix)
            if "PRIVATE" in name:
                continue
            if name[0].isdigit():
                name = f"_{name}"
            value = int(child.get("init"))
            values.append((name, value))
        enum = CEnum(py_name, prefix)
        enum.values = values
        MACRO_ENUMS.append(enum)


def main():
    cache = {}
    temp_dir = tempfile.mkdtemp()

    structs = {}
    for header in HEADERS:
        fill_macros(header, cache)
        base_header = os.path.split(os.path.splitext(header)[0])[1]
        xml_filename = os.path.join(temp_dir, base_header + ".xml")
        cmd = f"castxml --castxml-output=1.0.0 -o {xml_filename} {header}"
        assert os.system(cmd) == 0

        structs.update(get_structs(header, xml_filename))

        get_enums(header, xml_filename)


    structs_body = "\n\n".join(str(struct) for struct in structs.values() if struct.parent is None)
    enums_body = "\n\n".join(str(enum) for enum in MACRO_ENUMS if enum.name != "IOC")
    iocs_body = "\n\n".join(str(enum) for enum in MACRO_ENUMS if enum.name == "IOC")
    
    fields = {
        "name": __package__,
        "date": datetime.datetime.now(),
        "system": platform.system(),
        "release": platform.release(),
        "version": platform.version(),
        "enums_body": enums_body,
        "structs_body": structs_body,
        "iocs_body": iocs_body,
    }
    text = TEMPLATE.format(**fields)
    text = black.format_str(text, mode=black.FileMode())
    print(text)


if __name__ == "__main__":
    main()